#!/bin/python

outpath = "out"
run = True
bin = "01"
oct = "01234567"
dec = "0123456789"
hex = "0123456789ABCDEF"
sym = ":=!+-*/&|~<>"
low = "abcdefghijklmnopqrstuvwxyz"
cap = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
ino = ["=", "!=", "<", "<=", ">", ">=", "+", "-", "*", "/", "&",
  "|", "~", ":=", ":-", "+=", "-=", "*=", "/=", "&=", "|=", "~=", "=>", "->"]
kwd = ["use", "new", "return", "if", "else", "then", "in", "is", "not",
  "and", "or", "matches", "break", "next", "for", "redo", "do", "echo", "raw"]
state = []
errors = []
tree = []
line_cnt = 0
expr_nest = 0
comm_nest = 0
indt_nest = 0
indnt = [0]
  
def parse_line(line):
  global state, run, tree, errors, line_cnt  
  buf_str, buf_sym, buf_num, buf_opr, buf_spc = "", "", "", "", ""

  def eval_sym(char):
      nonlocal buf_sym
      global state, run
      match buf_sym:
        case "__exit": run = False
        case _: pass
      buf_sym = ""; state.pop()
      match char:
        case ' '  : state += ["BSPC"]

  def eval_indnt(char):
      global state, low
      nonlocal buf_spc, buf_sym
      buf_spc = ""; state.pop()
      match char:
        case '#'  : state += ["COML"]
        case '_'  : buf_sym += char; state += ["SYMB"]
        case char if char in low: buf_sym += char; state += ["SYMB"]
        case '('  : state += ["PARL"] 
  
  state += ["LINE"]; line_cnt += 1
  for char in line:
    match state[-1], char:
      case "LINE", ' '  : buf_spc += char 
      case "LINE", _    : eval_indnt(char)
      
      case "COML", _    : pass

      case "COMB", '#'  : state[-1] = "COMA"
      case "COMB", '('  : state[-1] = "COMP"
      case "COMB", '\"' : state += ["COMQ"]
      case "COMB", _    : pass

      case "COMA", ')'  : state.pop()
      case "COMA", _    : state[-1] = "COMB"

      case "COMP", '#'  : state += ["COMB"]
      case "COMP", _    : state[-1] = "COMB"

      case "COMQ", '\"' : state.pop()
      case "COMQ", _    : pass

      case "PARL", '#'  : state[-1] = "COMB"
      case "PARL", _    : expr_nest += 1; state += ["EXPR"]

      case "SYMB", ' '  : eval_sym(char)
      case "SYMB", char if char in low: buf_sym += char
      case "SYMB", '_'  : buf_sym += char
      
      case "BSPC", _    : pass

      case _            : errors += [(line_cnt, state)]
    print((char, state[-1]), end=" ")
  print()

  match state[-1]:
    case "COML": state.pop()
    case "COMB": pass
    case "COMA": state[-1] = "COMB"
    case "COMP": state[-1] = "COMB"
    case "COMQ": state.pop()
    case "BSPC": state.pop()
    case "SYMB": eval_sym('\n')

def parse_args(args):
  global outpath
  usg = "help will be soon"
  ver = "0.0.1"
  f_usg = False
  f_ver = False
  tmp = False
  files = []
  errors = []
  for arg in args:
    if arg[0] == '-':
      match arg:
        case "--help" | "-h": f_usg = True
        case "--version" | "-v": f_ver = True
        case "-o": tmp = True
        case _: errors += ["fatal: unknown option: " + arg]
    else:
      if tmp: outpath = arg; tmp = False
      else: files += [arg]
  if f_usg: print(usg); exit(0)
  if f_ver: print(ver); exit(0)
  return files 
 
if __name__ == "__main__":
  import sys
  paths = parse_args(sys.argv[1:])
  if len(paths) > 0:
    contents = []
    for path in paths:
      with open(path,"r") as file: contents += [file.read().splitlines()]
    for content in contents:
      for line in content: parse_line(line)
  else:
    while run: print("> ", end=""); parse_line(input())
    if len(errors):
      print(errors)
    else:
      print("ok")
